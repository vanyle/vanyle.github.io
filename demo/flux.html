<!DOCTYPE html>
<html>
	<head>
		<title>Fields</title>
		<meta charset="utf8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>
			html,body{
			  background-color: #fff;
			  width: 100%;
			  padding:0;
			  margin:0;
			  z-index:-1;
			  display: block;
			}
			body{
				margin-bottom:20px;
			}
			*{
				position: relative;
				box-sizing: border-box;
				font-family: "Helvetica","sans-serif";
				font-weight: lighter;
			}
			h1{
				text-align: center;
			}
			h2{
				padding:10px;
				font-size:2em;
			}
			canvas{
				width: 500px;
				height: 500px;
				z-index:-1;
				padding:0;
				border: 1px solid black;
				display: block;
				margin-left:auto;
				margin-right:auto;
			}
			p{
				margin:auto;
				width:70%;
				padding:10px;
			}
			li{
				padding:5px;
			}
			ul{
				margin:auto;
				width:70%;
			}
			input[type=text]{
				width:80%;
				margin:3px;
				font-size:1.5em;
			}
			#formula{
				margin:auto;
				display: block;
				margin-bottom:10px;
				text-align:center;
				border:none;
				outline:none;
				border-bottom:3px solid #55b;
			}
		</style>
	</head>
	<body>
		<h1>Ce jeu est une introduction interactive aux champs de vecteurs. Vous voilà prévenus !</h1>
		<hr/>
		<h2>C'est quoi un vecteur ?</h2>
		<canvas id="c1" width="300" height="300"></canvas>
		<p>
			Basiquement, un vecteur, c'est un objet mathématique qui représente un déplacement (ici en 2 dimensions c'est à dire sur un plan). <br/>
			On représente donc généralement un vecteur comme une flèche. Comme ici j'ai eu la flemme de faire une flèche, ça sera un trait avec un rond au bout.<br/>
			Avec les vecteurs, ce qui compte, c'est pas d'où on part ou où on arrive mais le chemin parcouru. En gros, on peut donc déplacer la flèche et le vecteur restera le même.<br/>
			Au dessus, on voit comment on va ici représenter les vecteurs. Comme plus tard, on va voir des schémas avec beaucoup de vecteurs en même temps, on va leur attribuer une couleur
			qui correspond à leur longueur. Comme ça, dans des figures avec pleins de vecteurs, les gros vont pas empêcher de voir les petits.
			Un vecteur est caractérisé par un couple de nombre : ses coordonnées qui correspond à combien on doit se déplacer vers la droite et vers le haut pour se déplacer comme le vecteur. 
		</p>
		<h2>Les champs de vecteurs !</h2>
		<canvas id="c2" width="400" height="400"></canvas>
		<p>
			Un champ de vecteurs, c'est juste un plan où on a associer à chaque point un vecteur. Comme j'ai pas la place de dessiner tous les vecteurs j'en dessine que quelques uns.
			Voilà un curseur pour voir ce qui se passe quand on augmente le nombre de vecteurs affichés: <br/>
			<em>Vecteurs affichés</em> : <input type="range" min="10" max="50" step="1" id="vcount_c2" value="20"/><br/>
			Dans le champs affiché au dessus, plus un vecteur est loin du centre, plus il est petit, de plus, les vecteurs se déplacent en s'éloignant du centre.
			La fonction associée à ce champ est f(x,y) = (x,y). En effet, les coordonnées du vecteur affiché sont égal à leur position (par exemple, le vecteur à l'origine est nul)
		</p>
		<h2>Des champs qui changent</h2>
		<canvas id="c3" width="400" height="400"></canvas>
		<p>
			Les champs peuvent évoluer en fonction du temps ou de l'action de quelque chose. Voici un petit exemple. Essayez de trouver la formule de ce champs ! 
			(mx et my sont les coordonnées de la souris)
		</p>
		<h2>Des champs plus compliqués</h2>
		<p>En tout cas, dessiner des champs, c'est joli. En voilà un autre !</p>
		<canvas id="c4" width="400" height="400"></canvas>
		<p>La formule du précédent, c'était f(x,y) = (x-mx,y-my). Comme ça, l'origine "suit" la position de la souris. Essayez de trouver la formule de celui-ci ! (Il est plus tordu.)
		Le précise que c'est que des +,x,-,/ avec x,y, mx et my. Pas de cosinus et autres fonctions compliquées.</p>
		<h2>La météo et les cercles.</h2>
		<p>
			La réponse s'était f(x,y) = (y * mx,x * my). Mais le plus intéressant c'est que le champ avait tendance à "tourner", à "faire des cercles".
			On comprend donc l'intérêt des champs en météorologie pour modéliser des vents, des tornades. Cependant, un outils cool serait une fonction qui à chaque
			point d'un champ donne un nombre qui décrit à quel point ça "tourne" à cet endroit et dans quelle direction. Un tel outil existe ! ça s'appelle le rotationnel !<br/>
			On le calcul comme ça : rotF = dFy / dx - dFx / dy.<br/>
			Le calcul est pas important. On va cette fois colorer les vecteurs en fonction de la valeur du rotationnel est pas en fonction de leur longeur pour voir ce que ça fais.
			Attention, cette définition du rotationnel n'est valable qu'en 2 dimensions !
		</p>
		<h2>Tornades !</h2>
		<canvas id="c5" width="400" height="400"></canvas>
		<p>
			On voit que le rotationnel est le même pour tout le champs ! C'est logique, il semble que tout le champ "tourne au même rythme". <br/>
			Il vaut ici : <em id="rot_c5"></em><br/>
			Le signe du rotationnel indique le sens de rotation : positif = sens trigonométrique. La valeur indique l'intensité de la rotation.
		</p>
		<h2>Rotationnel variable (et arc-en-ciels !!!!)</h2>
		<canvas id="c6" width="400" height="400"></canvas>
		<p>Cette fois-ci, le rotationnel varie dans le champ (comme l'indique le titre ...) Quelle est la formule utilisée pour fabriquer ce champ ? #défiAntoine</p>
		<h2>Bac à sable</h2>
		<p>
			Bon, vous avez vu tous ces champs cools et jolis, je suppose que vous voulez créer les votres non ?
			Le <em>Bac à Sable</em> est là pour ça. Mettez dans la zone de texte la formule de votre champ et je vais
			essayer de le dessiner.
		</p>
		<p>
			2 ou 3 précisions, voilà des exemples de formules valides:
		</p>
			<ul>
				<li><input type="text" value="x+2*x,y+x" disabled="true"/></li>
				<li><input type="text" value="cos(x),arctan(y)" disabled="true"></li>
				<li><input type="text" value="mx,my" disabled="true"></li>
			</ul>
		<p>
			Si la formule n'est pas valide, elle va être écrite en rouge.
		</p>
		<p>
			<em>Vecteurs affichés</em> : <input id="vcount_c7" type="range" min="5" max="50" step="1" value="20"/><br/>
			<em>Mode de coloraton</em> : <select id="color_c7"><option value="l">Longueur</option><option value="r">Rotationnel</option></select>
		</p>
		<input id="formula" placeholder="Formule" value="" type="text">
		<canvas width="600" height="600" id="c7"></canvas>
	</body>
	<script>
		"use strict";
		addEventListener('load',function(){

			let vf1 = new vectorFielder(_('c1'));
			//vf1.maxlength = 10;
			vf1.setOneVector();
			vf1.maxlength = 5;
			vf1.fieldFunction = function(x,y){
				return [this.mouseX()*10,this.mouseY()*10];
			}
			vf1.render(true);

			// -----------------------------------------------------------------------

			let vf2 = new vectorFielder(_('c2'));
			vf2.maxlength = 2;
			vf2.lengthExtend = 6;
			vf2.fieldFunction = function(x,y){
				return [x,y];
			}
			bind(_('vcount_c2'),function(v){
				vf2.vectSpace = v;
				vf2.setField(1);
				vf2.render(true);
			});

			// -----------------------------------------------------------------------

			let vf3 = new vectorFielder(_('c3'));
			vf3.vectSpace = 10;
			vf3.setField(1);
			vf3.lengthExtend = 8;
			vf3.maxlength = 0.4;
			vf3.fieldFunction = function(x,y){
				return [x-this.mouseX(),y-this.mouseY()];
			}
			vf3.render(true);

			// -----------------------------------------------------------------------

			let vf4 = new vectorFielder(_('c4'));
			vf4.vectSpace = 10;
			vf4.setField(1);
			vf4.lengthExtend = 8;
			vf4.maxlength = 0.4;
			vf4.fieldFunction = function(x,y){
				return [y*this.mouseX()*4,x*this.mouseY()*4];
			}
			vf4.render(true);

			// -----------------------------------------------------------------------

			let vf5 = new vectorFielder(_('c5'));
			let rot_c5 = _('rot_c5');
			vf5.vectSpace = 10;
			vf5.setField(1);
			vf5.lengthExtend = 8;
			vf5.maxlength = 0.4;
			vf5.ondraw = function(){
				rot_c5.innerHTML = prettifyInt(vf5.vectorToColor(0,0));
			}
			vf5.fieldFunction = function(x,y){
				return [y*this.mouseX()*4,x*this.mouseY()*4];
			}
			vf5.vectorToColor = function(x,y){
				// compute rot (2d only): dFy / dx - dFx/dy
				// small ~= 0
				let fx = (argx) => argx*this.mouseY()*4;
				let fy = (argy) => argy*this.mouseX()*4;
				return (fy(x+small) - fy(x))/small - (fx(y+small) - fx(y))/small;
			}
			vf5.render(true);

			// -----------------------------------------------------------------------

			let vf6 = new vectorFielder(_('c6'));
			vf6.vectSpace = 10;
			vf6.setField(1);
			vf6.lengthExtend = 20;
			vf6.maxlength = 0.2;
			vf6.fieldFunction = function(x,y){
				return [y*y*this.mouseX()*4,x*x*this.mouseY()*4];
			}
			vf6.vectorToColor = function(x,y){
				// compute rot (2d only): dFy / dx - dFx/dy
				// small ~= 0
				let fx = (argx) => argx*argx*this.mouseY()*4;
				let fy = (argy) => argy*argy*this.mouseX()*4;
				return (fy(x+small) - fy(x))/small - (fx(y+small) - fx(y))/small;
			}
			vf6.render(true);

			// -----------------------------------------------------------------------

			let vf7 = new vectorFielder(_('c7'));
			vf7.lengthExtend = 20;
			vf7.maxlength = 0.2;
			vf7.fieldFunction = function(x,y){
				return [x,y];
			}
			_('color_c7').onchange = function(){
				let val = _('color_c7').value;
				if(val === "r"){
					recomputeRot();
				}else if(val === "l"){
					vf7.vectorToColor = function(x,y){
						return x*x+y*y;
					}
				}
				vf7.render(true);
			}
			function recomputeRot(){
				let fx = function(argx,argy){return vf7.fieldFunction(argx,argy)[0];};
				let fy = function(argx,argy){return vf7.fieldFunction(argx,argy)[1];};

				vf7.vectorToColor = function(x,y){
					// compute rot (2d only): dFy / dx - dFx/dy
					// small ~= 0
					return (
						(fy(x+small,y) - fy(x,y))/small - (fx(x,y+small) - fx(x,y))/small
					);
				}
			}
			bindtext(_('formula'),function(v){
				let cos = function(x){return Math.cos(x);};
				let sin = function(x){return Math.sin(x);};
				let tan = function(x){return Math.tan(x);};
				let arccos = function(x){return Math.acos(x);}
				let arcsin = function(x){return Math.asin(x);}
				let arctan = function(x){return Math.atan(x);}
				v = v.replace(/mx/g,"vf7.mouseX()");
				v = v.replace(/my/g,"vf7.mouseY()"); // totally not a dirty hack
				try{
					let f;
					eval("f = function(x,y){return ["+v+"];}");
					var test  = f(0,0);
					if(typeof test[0] === "number" && typeof test[1] === "number" && typeof test === "object"){
						_('formula').style.color = 'black';
						vf7.fieldFunction = f;
						if(_('color_c7').value === "r"){
							recomputeRot();
						}
						vf7.render(true);
						return;
					}else{
						throw "Array with length 2 required";
					}
				}catch(err){
					_('formula').style.color = 'red';
					return;
				}
			});
			bind(_('vcount_c7'),function(v){
				vf7.vectSpace = v;
				vf7.setField(1);
				vf7.render(true);
			});

			function draw(){
				vf1.render();
				vf2.render();
				vf3.render();
				vf4.render();
				vf5.render();
				vf6.render();
				vf7.render();
				requestAnimationFrame(draw);
			}
			draw();
		});
	</script>
	<script>
		// Tiny vector field library ! :)
		let mousex = 0,mousey = 0;
		const small = 0.001; // lim h -> 0

		document.addEventListener('mousemove',function(e){
			mousex = e.clientX;
			mousey = e.clientY;
		});
		function bind(element,call){
			element.onmousedown = function(){
				element.isclicked = true;
			}
			element.onmouseup = function(){
				element.isclicked = false;
			}
			element.onmousemove = function(){
				if(element.isclicked){
					call(element.value);
				}
			}
			call(element.value);
		}
		function bindtext(element,call){
			element.onkeyup = function(){
				call(element.value);
			}
		}

		function _(e){return document.getElementById(e)};
		function vectorFielder(canvasObject){
			this.bg = "#fff";
			this.textcolor = "#000";
			this.c = canvasObject;
			this.w = this.c.width;
			this.h = this.c.height;
			this.g = this.c.getContext('2d');
			this.lengthExtend = 1.5;
			this.showMousePos = false;
			this.textSize = 1/20;
			this.vectors = []; // vector positions
			this.vectSpace = 20; // avg space between vectors.
			this.maxlength = 1;
			this.fieldFunction = function(x,y){ // default : constant vector field
				return [1,1];
			}
			this.vectorToColor = function(x,y){
				return Math.sqrt(x*x+y*y); // color is based on length by default.	
			}
			this.ondraw = function(){

			}
		}
		vectorFielder.prototype.setOneVector = function(){
			this.vectors = [[0,0]]; // vector position when rendered
		}
		vectorFielder.prototype.setField = function(density){ // density is assumed to be 1 most of the time.
			this.vectors = [];
			let i,j;
			for(i = 0;i < this.w/this.vectSpace;i++){
				for(j = 0;j < this.h/this.vectSpace;j++){
					this.vectors.push([
						(i/this.w*this.vectSpace)*2 - 1,
						(j/this.h*this.vectSpace)*2 - 1
					]);
				}
			}
		}
		vectorFielder.prototype.colorizeVector = function(x,y){
			let lengthSquared = x*x + y*y;
			let length = Math.sqrt(lengthSquared);
			if(length < this.maxlength){ // if the length is short, display the real length
				return [
					x * this.vectSpace/2 * this.lengthExtend, // stetch a bit
					y * this.vectSpace/2 * this.lengthExtend,
					this.vectorToColor(x,y)
				];
			}else{ // else, minimise the length to 1
				return [
					(x / length) * this.maxlength * this.vectSpace/2 * this.lengthExtend,
					(y / length) * this.maxlength * this.vectSpace/2 * this.lengthExtend,
					this.vectorToColor(x,y)
				];
			}
		}
		vectorFielder.prototype.mouseX = function(){
			return (((mousex - this.c.offsetLeft + scrollX) / this.c.offsetWidth) * 2 - 1);
		}
		vectorFielder.prototype.mouseY = function(){
			return (((mousey - this.c.offsetTop + scrollY) / this.c.offsetHeight) * 2 - 1);
		}
		vectorFielder.prototype.isMouseInside = function(){
			return -1 < this.mouseX() && this.mouseX() < 1 && -1 < this.mouseY() && this.mouseY() < 1;
		}
		vectorFielder.prototype.render = function(force){
			if(!this.isMouseInside() && !force){
				return; // Don't render is the mouse is outside the canvas.
			}
			this.ondraw();
			let g = this.g;
			g.fillStyle = this.bg;
			g.fillRect(0,0,this.w,this.h);
			if(this.showMousePos){
				g.fillStyle = this.textcolor;
				g.font = Math.round(this.w*this.textSize)+"px Arial";
				g.fillText("("+prettifyInt(this.mouseX())+";"+prettifyInt(this.mouseY())+")",0,this.w*this.textSize);
			}

			let v,currv;

			for(v in this.vectors){
				currv = this.vectors[v];
				vdata = this.fieldFunction(currv[0],currv[1]); // computes the vectors

				// makes the data displayable (adds color and stretchs the vectors according to the size of the canvas and stuff ...)
				vdata = this.colorizeVector(vdata[0],vdata[1]);
				g.strokeStyle = numberToColor(vdata[2]);
				g.fillStyle = g.strokeStyle;

				g.beginPath();
				g.moveTo(
					(currv[0]+0.5)*this.w,
					(currv[1]+0.5)*this.h
					);
				g.lineTo(
					(currv[0]+0.5)*this.w + vdata[0],
					(currv[1]+0.5)*this.h + vdata[1]
					);
				g.stroke();

				g.beginPath();
				g.arc(
					(currv[0]+0.5)*this.w + vdata[0],
					(currv[1]+0.5)*this.h + vdata[1],
					this.vectSpace/4,
					0,
					Math.PI*2
				);
				g.fill();
			}
		}
		function numberToColor(number){ // Todo arctan number instead of just mod (NB: number is assumed to be positiv)
			number = Math.atan(number) * 720/Math.PI;

			return "hsl("+number%360+", 100%, 50%)";
		}
		function prettifyInt(number){ // fancy rounding
			var n = Math.round(number*100)/100;
			if(n === Math.floor(n)){ // is integer
				n += ".";
			}
			n += ""; // cast to string
			while(n.length < 6){
				n += "0";
			}
			return n;
		}
	</script>
</html>