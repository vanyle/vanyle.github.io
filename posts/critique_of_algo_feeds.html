
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="An ASG website">
	<meta name="author" content="vanyle">
	<meta name="keywords" content="blog, asg, vanyle">
	<title>Antoine's blog</title>
	<style>
		body,html{
			font-family: sans-serif;
			display: flex;
			flex-direction: column;
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
		}
		header{
			display: flex;
			align-items: stretch;
			justify-content: center;
		}
		header a{
			text-decoration: none;
		}
		a{
			color: inherit;
			cursor: pointer;
		}
		main{
			padding: 10px;
		}
		header > div{
			width: min(max(60%, 500px), 100%);
			height: 100%;
			display: flex;
			align-items: stretch;
			justify-content: space-between;
		}
		nav{
			display: flex;
			align-items: center;
			height: 100%;
		}
		header h1{
			display: flex;
			align-items: center;
			font-size: 2em;
			font-weight: normal;
		}
	</style>
	<style>
@import url('https://fonts.cdnfonts.com/css/oswald-4');
header{
	padding: 30px 0px;
	border-top: 4px solid #36f;
	background-color: white;
	margin-bottom:15px;
	box-shadow:0 3px 1px 0px #333;
}
h2{
	color: #36f;
}
body{
	background-color:#36f;
	justify-content: space-between;
}
nav > *{
	font-family: "Oswald", sans-serif;
	padding: 10px 10px;
	margin: 0 10px;
	font-size: 1.3em;
	display: flex;
	justify-content: center;
	align-items: center;
	height: 100%;
	cursor: pointer;
	box-sizing: content-box;
	border-bottom: 5px solid transparent;
	transition: 300ms;
}
nav > *:hover{
	border-bottom: 5px solid #36f;
}
nav > *:active{
	transform: scale(0.9);
}
h1,h2,h3,h4,h5,h6{
	margin: 5px;
	font-family: "Oswald", sans-serif;
}
section{
	width: min(max(60%, 500px), 100%);
	box-sizing: border-box;
	padding:20px;
	background-color:white;
	margin: auto;
	display:flex;
	flex-direction: column;
}
.card{
	padding: 15px;
	margin: 10px;
	text-decoration:none;
	transition:300ms;
}
a{
	text-decoration:none;
}
p a{
	text-decoration:underline;
}
.card:hover{
	box-shadow:inset 0px 0px 0px 2px #333;
}
.card .title{
	cursor: pointer;
	font-weight: bold;
	display: inline-block;
	text-decoration: none;
	font-size: 1.4em;
	color: inherit;
	transition:300ms;
}
.card .title:active{
	transform: scale(0.9);
}
.card .title:hover{
	color:#333;
}
.card .time{
	color: #666;
}
footer{
	background-color: white;
	box-shadow:0 -3px 1px 0px #333;
	padding:5px 15px;
}
</style>

</head>
<body>
	<header>
		<div>
			<h1>Antoine's blog</h1>
			<nav>
				<a href="/">Home</a>
				<a href="/about.html">About</a>
				<a href="/search.html">Search</a>
			</nav>
		</div>
	</header>
	<section>
	

<h1>A critique of content feeds curated by &quot;Popularity&quot;</h1>
<p>Like a lot of people, I spend a lot of time online.
And like a lot of people, I like to spend that time mindlessly scrolling through
posts and content.</p>
<p>I've tried a large number of these feeds including (not listed in any specific order):</p>
<ul>
<li>Facebook</li>
<li>Twitter</li>
<li>Discord Chats</li>
<li>Telegram Groups / Channels</li>
<li>HackerNews</li>
<li>Reddit</li>
<li>RSS</li>
<li>Mails</li>
<li>Youtube</li>
<li>...</li>
</ul>
<p>I put these in 2 categories: popularity ranked feeds and recency ranked feeds.
Here is a table with the some feeds you can find in each of the categories:</p>
<table>
<thead>
<tr>
<th>Popularity Based</th>
<th>Recency based</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reddit (by default)</td>
<td>RSS</td>
</tr>
<tr>
<td>Twitter (by default)</td>
<td>Mails</td>
</tr>
<tr>
<td>Youtube Home</td>
<td>Telegram Groups</td>
</tr>
<tr>
<td>HackerNews Homepage</td>
<td>Youtube Subscription</td>
</tr></tbody></table>
<p>In a recency feed, the elements (blog posts, videos, chat messages, etc...) appear in chronological order
while in popularity feeds, they appear based on another metric (algorithmic, upvotes, trending, etc...)</p>
<p>While you might believe at first glance that popularity based content is better,
I'm here to argue that that's not the case.
Let's compare for example HackerNews and an RSS feeds. Both contain mainly links to
various blogs and articles. The difference (apart from comments) is that the content
from HackerNews comes from a voting system whereas the content in your RSS feed
is whatever the people you follow have published.</p>
<p>This has multiple consequences. The first is that the same common &quot;interesting&quot; topics always popup on
the feed month after month (the so-called &quot;reddit effect&quot;). As new users come to the site and always
find the same topics interesting, the same kind of link is surfaced over and over again.</p>
<p>When first browsing the site, you find this awesome as you get to learn a lot and discover new crazy
domains, this gets tiresome quite quickly.</p>
<p>With RSS feeds, while the individual article might look less appealing, because you are following the
same people, they provide new insights everytime (as long as they don't repeat themselves), and in the
long run, you are more satisfied with the content you consume and you discover non-mainstream topics
that rarely appear on more common popularity feeds.</p>
<p>Another perverse effect of popularity feeds (eventhough this is more true of algorithmic feeds specifically
which are a specific kind of popularity feed.) is that they tend to always show new content when you reload the
page. In the new reload field, there is a mix of old previously seen content and new stuff.</p>
<p>This creates a gambling machine like effect as your refresh the page multiple time in order to access the new stuff.
And not only you miss content that might have interested you because of the algorithm, but you spend more time
on the website searching for the content you are truely interested in.
Moreover, the randomness of the reward increases the odds of being addicted to the website (based on research performed
on rats with random rewards when pressing a button, go google it yourself)</p>
<p>All in all, I know that everybody is not able to stay focused all the time and we all need some mindnumbing distraction.
Well, if you want to have a feed as this distraction, I'd recommend you not to pick an popularity based feed but a recency based
one. Check the table above for some example of recency based feeds (RSS in particular is quite neat!)</p>

	</section>
	<footer>
			<p> © 2023 - Antoine Delègue - Powered by ASG</p>

	</footer>
</body>



	

	

	<script>
		addEventListener("DOMContentLoaded", () => {
			if(typeof window.hljs !== "undefined"){
				document.body.querySelectorAll("code.language-mermaid").forEach((el) => {
					
					el.className = "mermaid";
					let tempId = "tempId51432"; 
					el.id = tempId;
					let prevParent = el.parentElement; 
					let fn = (svgCode, bindFunctions) => {
						let d = document.createElement("div");
						d.innerHTML = svgCode;
						prevParent.append(d); // for some reason, el get's removed from the DOM, so we add it back.
					};
					mermaid.mermaidAPI.render(tempId,el.innerText+"",fn);
					el.id = "";
				});
			}

			if(typeof window.hljs !== "undefined"){
				window.hljs.highlightAll();
			}

			if(typeof window.renderMathInElement !== "undefined"){
				renderMathInElement(document.body, {
					delimiters: [
						{left: '$$', right: '$$', display: true},
						{left: '$', right: '$', display: false},
						{left: '\\(', right: '\\)', display: true},
						{left: '\\[', right: '\\]', display: false}
					],
					throwOnError : false
				});
			}

			// Live reload. Try to reconnect when the connection fails.
						if(location.hostname === "localhost"){
				window.ws = null;
				window.wsIsClosed = true;
				let connectionMaker = () => {
					if(wsIsClosed){
						wsIsClosed = false;
						try{
							console.log("connecting...");
							ws = new WebSocket("ws://"+location.host+"/ws");
						}catch(err){} // don't spam the console.
						ws.onmessage = (msg) => {
							wsIsClosed = false;
							if(msg.data == "reload"){
								location.reload();
							}else{
								console.log(msg);
							}
						}
						ws.onopen = () => {
							console.log("Connected!");
							wsIsClosed = false;
						}
						ws.onerror = () => {
							wsIsClosed = true;
						};
						ws.onclose = () => {
							wsIsClosed = true;
						};
					}
				};
				setInterval(connectionMaker, 1000);
				connectionMaker();
			}
			
		});
	</script>


</html>